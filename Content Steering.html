<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Content Steering - Simulation Interface</title>
    <script src="./Content Steering_files/dash.all.debug.js.baixados"></script>
    <link href="./Content Steering_files/bootstrap.min.css" rel="stylesheet" />
    <link href="./Content Steering_files/main.css" rel="stylesheet" />
    <style>
      video { width: 100%; max-width: 640px; height: auto; background-color: black; }
      figure.cdn-selection { margin: 0 10px 0 0; display: inline-block; vertical-align: top;}
      img.cdn-selection { width: 50px; }
      .figure-caption { text-align: center; font-size: 0.75em; }
      #cdn-selection-container { margin: 5px 0 15px 0; min-height: 70px;}
      .table td, .table th { font-size: 0.85em; padding: 0.4rem; }
      pre { white-space: pre-wrap; word-break: break-all; font-size: 0.8em; max-height: 100px; overflow-y: auto; }
      .simulation-controls label { margin-right: 5px; }
      .simulation-controls input, .simulation-controls select { margin-bottom: 10px; }
      .simulation-controls .form-select, .simulation-controls .form-control-sm { margin-right: 5px;}
    </style>
</head>
<body>
    <main>
      <div class="container py-4">
        <header class="pb-3 mb-4 border-bottom">
          <img src="./Content Steering_files/dashjs-logo.png" width="180" alt="DASH-IF Logo"/>
          <h4 style="display: inline-block; margin-left: 20px; vertical-align: middle;">Simulation Interface (CSV Data Focus)</h4>
        </header>

        <div class="row mt-2 mb-3 p-3 border rounded-3 simulation-controls">
            <h5>Simulation Setup</h5>
            <div class="row mb-2">
                <div class="col-md-4">
                    <label for="simDuration">Total Duration (s):</label>
                    <input type="number" id="simDuration" value="120" class="form-control form-control-sm d-inline-block" style="width: 80px;">
                </div>
                <div class="col-md-8">
                    <label for="initialSimLat">Initial Lat:</label>
                    <input type="number" step="any" id="initialSimLat" value="-20.0" class="form-control form-control-sm d-inline-block" style="width: 90px;">
                    <label for="initialSimLon" class="ms-2">Initial Lon:</label>
                    <input type="number" step="any" id="initialSimLon" value="-40.0" class="form-control form-control-sm d-inline-block" style="width: 90px;">
                </div>
            </div>
            <div class="row mb-2 align-items-center">
                <div class="col-md-6">
                    <label for="simMovementTarget_1">Movement 1:</label>
                    <select id="simMovementTarget_1" class="form-select form-select-sm d-inline-block" style="width: auto;">
                        <option value="none">Stay Still</option>
                    </select>
                    Start @ <input type="number" id="simMovementStartTime_1" value="10" class="form-control form-control-sm d-inline-block" style="width: 60px;" title="Movement 1: Start after X seconds">s
                    Duration <input type="number" id="simMovementDuration_1" value="30" class="form-control form-control-sm d-inline-block" style="width: 60px;" title="Movement 1: Time in seconds to reach target">s
                </div>
                <div class="col-md-6">
                    <label for="simSpamTarget_1">Spam Cache 1:</label>
                    <select id="simSpamTarget_1" class="form-select form-select-sm d-inline-block" style="width: auto;">
                        <option value="none">No Spam</option>
                    </select>
                    @ <input type="number" id="simSpamStartTime_1" value="20" class="form-control form-control-sm d-inline-block" style="width: 60px;" title="Spam 1: Start after X seconds">s
                    for <input type="number" id="simSpamDuration_1" value="20" class="form-control form-control-sm d-inline-block" style="width: 60px;" title="Spam 1: Duration in seconds">s
                </div>
            </div>
            <div class="row mb-3 align-items-center">
                <div class="col-md-6">
                    <label for="simMovementTarget_2">Movement 2:</label>
                    <select id="simMovementTarget_2" class="form-select form-select-sm d-inline-block" style="width: auto;">
                        <option value="none">No Movement</option>
                    </select>
                    Start @ <input type="number" id="simMovementStartTime_2" value="70" class="form-control form-control-sm d-inline-block" style="width: 60px;" title="Movement 2: Start after X seconds">s
                    Duration <input type="number" id="simMovementDuration_2" value="30" class="form-control form-control-sm d-inline-block" style="width: 60px;" title="Movement 2: Time in seconds to reach target">s
                </div>
                <div class="col-md-6">
                    <label for="simSpamTarget_2">Spam Cache 2:</label>
                    <select id="simSpamTarget_2" class="form-select form-select-sm d-inline-block" style="width: auto;">
                        <option value="none">No Spam</option>
                    </select>
                    @ <input type="number" id="simSpamStartTime_2" value="80" class="form-control form-control-sm d-inline-block" style="width: 60px;" title="Spam 2: Start after X seconds">s
                    for <input type="number" id="simSpamDuration_2" value="20" class="form-control form-control-sm d-inline-block" style="width: 60px;" title="Spam 2: Duration in seconds">s
                </div>
            </div>
            <div class="col-md-12 mt-1">
                <button type="button" id="button_StartControlledSim" class="btn btn-success btn-sm me-2" disabled>Start Simulation</button>
                <button type="button" id="button_StopSim" class="btn btn-danger btn-sm me-2" disabled>Stop Simulation</button>
                <button type="button" id="button_ResetSimUI" class="btn btn-warning btn-sm">Reset UI & Sim State</button>
            </div>
        </div>

        <div class="row">
          <div class="col-md-7">
            <div class="input-group mb-2">
              <input type="text" id="manifest" class="form-control form-control-sm" placeholder="MPD URL" value="https://video-streaming-cache-1/Eldorado/4sec/avc/manifest.mpd"/>
              <button type="button" id="load-button" class="btn btn-primary btn-sm">Load MPD</button>
            </div>
            <div class="form-check mb-2">
                <input class="form-check-input" type="checkbox" value="" id="autoStartCheckbox">
                <label class="form-check-label" for="autoStartCheckbox" style="font-size: 0.9em;">
                    Auto-start simulation on MPD load
                </label>
            </div>
            <video controls="true" muted="true" preload="metadata"></video>
             <div class="mt-2">
                Sim Time: <span id="simCurrentTimeDisplay">0</span>s <br>
                Client Pos: Lat <input type="text" id="current-latitude" class="form-control-sm" style="width:90px;" readonly/>,
                Lon <input type="text" id="current-longitude" class="form-control-sm" style="width:90px;" readonly /> <br>
                Movement 1: <span id="simMovementStatus_1">Inactive</span> | Movement 2: <span id="simMovementStatus_2">Inactive</span> <br>
                Spam 1: <span id="simSpamStatus_1">Inactive</span> | Spam 2: <span id="simSpamStatus_2">Inactive</span>
            </div>
          </div>
          <div class="col-md-5">
            <div class="p-2 border rounded-3" style="max-height: 450px; overflow-y: auto;">
              <h6>CDN Selection (Active for Segments)</h6>
              <div id="cdn-selection-container"></div>
              <h6 style="margin-top: 10px;">Steering Decision (Priority)</h6>
              <div id="steering-decision-display" style="font-size:0.8em; padding:5px; background-color:#f8f9fa; border-radius:3px;">N/A</div>
               <h6 style="margin-top: 10px;">Steering Service Raw Data</h6>
              <div class="table-responsive">
                <table class="table table-sm">
                   <tbody>
                    <tr><td>Timestamp</td><td id="steering-request-timestamp">N/A</td></tr>
                    <tr><td>Req URL</td><td><span id="steering-request-url" style="word-break: break-all;">N/A</span></td></tr>
                    <tr><td>Clones</td><td><pre><span id="steering-pathway-cloning">N/A</span></pre></td></tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
        <footer class="pt-3 mt-4 text-muted border-top">Simulation Interface (CSV Data Focus)</footer>
      </div>
    </main>

    <script>
        let player;
        let currentSegmentServiceLocation = { audio: null, video: null };
        let cdnIconDomElements = {};
        const CACHE_COORDS = {
            "video-streaming-cache-1": { lat: -23.0, lon: -47.0, label: "Cache 1 (BR)" },
            "video-streaming-cache-2": { lat: -33.0, lon: -71.0, label: "Cache 2 (CL)" },
            "video-streaming-cache-3": { lat:  5.0,  lon: -74.0, label: "Cache 3 (CO)" }
        };
        const LATENCY_MS_PER_KM = 0.1;

        let simTimer = null;
        let simElapsedTime = 0;

        let simMovementActive_1 = false, simMovementActive_2 = false;
        let simSpamActive_1 = false, simSpamActive_2 = false;
        let simIntervalID_movement_1 = null, simIntervalID_movement_2 = null;
        let simIntervalID_spam_1 = null, simIntervalID_spam_2 = null;

        let movementStarted_1 = false; 
        let movementStarted_2 = false; 

        let simCurrentLat, simCurrentLon;
        let isSimulationRunning = false;
        let manifestSuccessfullyLoaded = false;

        let onManifestLoadedCallback = null;
        let onManifestErrorCallback = null;
        let onStreamInitForPlay = null;
        let onStreamInitForAutomaticPlay = null;

        let fragmentLoadStarts = {};

        function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function deg2rad(deg) {
            return deg * (Math.PI / 180);
        }

        function stopInterval(intervalId) {
            if (intervalId != null) clearInterval(intervalId);
        }

        function setupPlayer() {
            const videoElement = document.querySelector("video");
            if (player) {
                if (onManifestLoadedCallback) player.off(dashjs.MediaPlayer.events.MANIFEST_LOADED, onManifestLoadedCallback);
                if (onManifestErrorCallback) player.off(dashjs.MediaPlayer.events.ERROR, onManifestErrorCallback);
                if (onStreamInitForPlay) player.off(dashjs.MediaPlayer.events.STREAM_INITIALIZED, onStreamInitForPlay);
                if (onStreamInitForAutomaticPlay) player.off(dashjs.MediaPlayer.events.STREAM_INITIALIZED, onStreamInitForAutomaticPlay);
                player.reset();
            }
            player = dashjs.MediaPlayer().create();
            player.initialize(videoElement, null, false);
            player.on(dashjs.MediaPlayer.events.FRAGMENT_LOADING_STARTED, _onFragmentLoadingStarted);
            player.on(dashjs.MediaPlayer.events.FRAGMENT_LOADING_COMPLETED, _onFragmentLoadingCompleted);
            player.on(dashjs.MediaPlayer.events.CONTENT_STEERING_REQUEST_COMPLETED, _onContentSteeringRequestCompleted);
            player.on(dashjs.MediaPlayer.events.ERROR, (e) => {
                console.error("Player Error (Global Listener):", e);
                if (e.error && e.error.code &&
                    (e.error.code === dashjs.MediaPlayer.errors.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE ||
                     e.error.code === dashjs.MediaPlayer.errors.MANIFEST_LOADER_LOADING_FAILURE_ERROR_CODE ||
                     e.error.code === dashjs.MediaPlayer.errors.DOWNLOAD_ERROR_ID_MANIFEST)
                ) {
                     console.error("[CLIENT] Global error listener caught manifest issue, disabling start.");
                     manifestSuccessfullyLoaded = false;
                     document.getElementById("button_StartControlledSim").disabled = true;
                }
            });
        }

        function init() {
            setupPlayer();
            document.getElementById("load-button").addEventListener("click", _load);
            document.getElementById("button_StartControlledSim").addEventListener("click", startControlledSimulation);
            document.getElementById("button_StopSim").addEventListener("click", stopCurrentSimulation);
            document.getElementById("button_ResetSimUI").addEventListener("click", resetSimulationUIAndState);

            populateSelect("simMovementTarget_1", "Stay Still");
            populateSelect("simSpamTarget_1", "No Spam");
            populateSelect("simMovementTarget_2", "No Movement");
            populateSelect("simSpamTarget_2", "No Spam");

            const cdnContainer = document.getElementById("cdn-selection-container");
            cdnContainer.innerHTML = ''; cdnIconDomElements = {};
            for (const cacheName in CACHE_COORDS) {
                _createIcon(cdnContainer, cacheName, cdnIconDomElements, "cdn");
            }
            _resetUIOnly();
            document.getElementById("button_StartControlledSim").disabled = true;
            document.getElementById("button_StopSim").disabled = true;
        }

        function populateSelect(selectId, noneOptionText) {
            const selectElement = document.getElementById(selectId);
            selectElement.innerHTML = '';
            if (noneOptionText) {
                const noneOpt = document.createElement("option"); noneOpt.value = "none";
                noneOpt.textContent = noneOptionText; selectElement.appendChild(noneOpt);
            }
            for (const cacheName in CACHE_COORDS) {
                const option = document.createElement("option"); option.value = cacheName;
                option.textContent = CACHE_COORDS[cacheName].label; selectElement.appendChild(option);
            }
        }

        function stopCurrentSimulation(pausePlayerAndSeek = true) {
            isSimulationRunning = false;
            if (simTimer) { clearInterval(simTimer); simTimer = null; }

            stopInterval(simIntervalID_movement_1); simIntervalID_movement_1 = null;
            stopInterval(simIntervalID_movement_2); simIntervalID_movement_2 = null;
            stopInterval(simIntervalID_spam_1); simIntervalID_spam_1 = null;
            stopInterval(simIntervalID_spam_2); simIntervalID_spam_2 = null;

            simMovementActive_1 = false; simMovementActive_2 = false;
            simSpamActive_1 = false; simSpamActive_2 = false;
            movementStarted_1 = false; 
            movementStarted_2 = false;


            if (pausePlayerAndSeek && player && manifestSuccessfullyLoaded) {
                if (player.isReady() && !player.isPaused()) {
                    player.pause();
                }
                if (player.isReady()){
                    player.seek(0);
                }
            }
            document.getElementById("button_StartControlledSim").disabled = !manifestSuccessfullyLoaded;
            document.getElementById("button_StopSim").disabled = true;
            document.getElementById("simMovementStatus_1").textContent = "Inactive";
            document.getElementById("simMovementStatus_2").textContent = "Inactive";
            document.getElementById("simSpamStatus_1").textContent = "Inactive";
            document.getElementById("simSpamStatus_2").textContent = "Inactive";
        }

        function _resetUIOnly() {
            simElapsedTime = 0;
            document.getElementById("simCurrentTimeDisplay").textContent = "0";
            const initialLatVal = parseFloat(document.getElementById("initialSimLat").value);
            const initialLonVal = parseFloat(document.getElementById("initialSimLon").value);
            simCurrentLat = isNaN(initialLatVal) ? -20.0 : initialLatVal;
            simCurrentLon = isNaN(initialLonVal) ? -40.0 : initialLonVal;
            document.getElementById("current-latitude").value = simCurrentLat.toFixed(5);
            document.getElementById("current-longitude").value = simCurrentLon.toFixed(5);
            document.getElementById("steering-decision-display").textContent = "N/A";
            document.getElementById("steering-request-timestamp").textContent = "N/A";
            document.getElementById("steering-request-url").textContent = "N/A";
            document.getElementById("steering-pathway-cloning").textContent = "N/A";
            currentSegmentServiceLocation = { audio: null, video: null };
            _updateActiveServerIcons();
            fragmentLoadStarts = {};
            document.getElementById("simMovementStatus_1").textContent = "Inactive";
            document.getElementById("simMovementStatus_2").textContent = "Inactive";
            document.getElementById("simSpamStatus_1").textContent = "Inactive";
            document.getElementById("simSpamStatus_2").textContent = "Inactive";
            movementStarted_1 = false; 
            movementStarted_2 = false;
         }

        function resetSimulationUIAndState() {
            stopCurrentSimulation(true); 
            _resetUIOnly(); 
            document.getElementById("button_StartControlledSim").disabled = true;
        }

        function startControlledSimulation() {
            if (!manifestSuccessfullyLoaded) {
                console.warn("[SIM_START] Attempted to start simulation, but manifest was not successfully loaded.");
                return;
            }
            if (isSimulationRunning) {
                console.warn("[SIM_START] Simulation is already running. Stop or Reset first.");
                return;
            }

            console.log("[SIM_START] Starting controlled simulation...");
            simElapsedTime = 0;
            
            simMovementActive_1 = false; simSpamActive_1 = false;
            simMovementActive_2 = false; simSpamActive_2 = false;
            movementStarted_1 = false;
            movementStarted_2 = false;

            stopInterval(simIntervalID_movement_1); simIntervalID_movement_1 = null;
            stopInterval(simIntervalID_spam_1);    simIntervalID_spam_1 = null;
            stopInterval(simIntervalID_movement_2); simIntervalID_movement_2 = null;
            stopInterval(simIntervalID_spam_2);    simIntervalID_spam_2 = null;

            if (simTimer) { clearInterval(simTimer); simTimer = null; }
            document.getElementById("simCurrentTimeDisplay").textContent = "0";
            isSimulationRunning = true;
            fragmentLoadStarts = {};

            function attemptPlayAfterStreamReady() {
                 if (player.getActiveStream() && player.isReady() && manifestSuccessfullyLoaded) {
                    console.log("[SIM_START_PLAY] Stream ready, seeking to 0 and playing.");
                    player.seek(0);
                    player.play();
                } else {
                    console.warn("[SIM_START_PLAY] Conditions not met to play after stream init (Stream Active:", player.getActiveStream(), "Player Ready:", player.isReady(), "Manifest Loaded:", manifestSuccessfullyLoaded, ")");
                }
            }

            if (player.getActiveStream() && player.isReady()) {
                attemptPlayAfterStreamReady();
            } else if (player.isReady()) {
                if (onStreamInitForPlay && player) player.off(dashjs.MediaPlayer.events.STREAM_INITIALIZED, onStreamInitForPlay);
                onStreamInitForPlay = function() {
                    if (!isSimulationRunning) return;
                    attemptPlayAfterStreamReady();
                    if (player) player.off(dashjs.MediaPlayer.events.STREAM_INITIALIZED, onStreamInitForPlay);
                };
                player.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, onStreamInitForPlay, null, { once: true });
                console.log("[SIM_START] Player ready, waiting for STREAM_INITIALIZED to play...");
            } else {
                console.error("[SIM_START] Player is not ready. Cannot start playback reliably.");
                isSimulationRunning = false;
                return;
            }

            document.getElementById("button_StartControlledSim").disabled = true;
            document.getElementById("button_StopSim").disabled = false;

            const duration = parseInt(document.getElementById("simDuration").value) || 120;

            const movementTarget_1 = document.getElementById("simMovementTarget_1").value;
            const movementStartTime_1 = parseInt(document.getElementById("simMovementStartTime_1").value);
            const desiredMovementDuration_1 = parseInt(document.getElementById("simMovementDuration_1").value) || 30;
            const spamTarget_1 = document.getElementById("simSpamTarget_1").value;
            const spamStartTime_1 = parseInt(document.getElementById("simSpamStartTime_1").value);
            const spamDuration_1 = parseInt(document.getElementById("simSpamDuration_1").value);

            const movementTarget_2 = document.getElementById("simMovementTarget_2").value;
            const movementStartTime_2 = parseInt(document.getElementById("simMovementStartTime_2").value);
            const desiredMovementDuration_2 = parseInt(document.getElementById("simMovementDuration_2").value) || 30;
            const spamTarget_2 = document.getElementById("simSpamTarget_2").value;
            const spamStartTime_2 = parseInt(document.getElementById("simSpamStartTime_2").value);
            const spamDuration_2 = parseInt(document.getElementById("simSpamDuration_2").value);

            simCurrentLat = parseFloat(document.getElementById("initialSimLat").value);
            simCurrentLon = parseFloat(document.getElementById("initialSimLon").value);
            if(isNaN(simCurrentLat)) simCurrentLat = -20.0;
            if(isNaN(simCurrentLon)) simCurrentLon = -40.0;
            document.getElementById("current-latitude").value = simCurrentLat.toFixed(5);
            document.getElementById("current-longitude").value = simCurrentLon.toFixed(5);
            document.getElementById("simMovementStatus_1").textContent = "Inactive";
            document.getElementById("simMovementStatus_2").textContent = "Inactive";
            document.getElementById("simSpamStatus_1").textContent = "Inactive";
            document.getElementById("simSpamStatus_2").textContent = "Inactive";

            simTimer = setInterval(() => {
                if (!isSimulationRunning) { clearInterval(simTimer); simTimer = null; return; }
                simElapsedTime++;
                document.getElementById("simCurrentTimeDisplay").textContent = simElapsedTime;

                
                if (movementTarget_1 !== "none" && simElapsedTime >= movementStartTime_1 && !movementStarted_1) {
                    movementStarted_1 = true; 
                    if (simMovementActive_2) {
                        console.log("Movement 1 starting: Interrupting active Movement 2.");
                        stopInterval(simIntervalID_movement_2); simIntervalID_movement_2 = null;
                        simMovementActive_2 = false;
                        document.getElementById("simMovementStatus_2").textContent = "Interrupted by M1";
                    }
                    simMovementActive_1 = true;
                    let timeRemainingInSim = duration - simElapsedTime;
                    let effectiveMoveDuration = Math.max(1, Math.min(desiredMovementDuration_1, timeRemainingInSim));
                    console.log(`Movement 1: Target=${movementTarget_1}, StartTime=${movementStartTime_1}, EffectiveDuration=${effectiveMoveDuration}s`);
                    startSimulatedMovement(movementTarget_1, simCurrentLat, simCurrentLon, effectiveMoveDuration, 1);
                    document.getElementById("simMovementStatus_1").textContent = `Moving (to ${CACHE_COORDS[movementTarget_1]?.label || movementTarget_1})`;
                }
                
                if (movementTarget_2 !== "none" && simElapsedTime >= movementStartTime_2 && !movementStarted_2) {
                    movementStarted_2 = true; 
                     if (simMovementActive_1) {
                        console.log("Movement 2 starting: Interrupting active Movement 1.");
                        stopInterval(simIntervalID_movement_1); simIntervalID_movement_1 = null;
                        simMovementActive_1 = false;
                        document.getElementById("simMovementStatus_1").textContent = "Interrupted by M2";
                    }
                    simMovementActive_2 = true;
                    let timeRemainingInSim = duration - simElapsedTime;
                    let effectiveMoveDuration = Math.max(1, Math.min(desiredMovementDuration_2, timeRemainingInSim));
                    console.log(`Movement 2: Target=${movementTarget_2}, StartTime=${movementStartTime_2}, EffectiveDuration=${effectiveMoveDuration}s`);
                    startSimulatedMovement(movementTarget_2, simCurrentLat, simCurrentLon, effectiveMoveDuration, 2);
                    document.getElementById("simMovementStatus_2").textContent = `Moving (to ${CACHE_COORDS[movementTarget_2]?.label || movementTarget_2})`;
                }

                
                if (spamTarget_1 !== "none" && simElapsedTime >= spamStartTime_1 && !simSpamActive_1) {
                    simSpamActive_1 = true;
                    startSimulatedCacheSpam(spamTarget_1, 1);
                    document.getElementById("simSpamStatus_1").textContent = `Spamming (${CACHE_COORDS[spamTarget_1]?.label || spamTarget_1})`;
                }
                if (simSpamActive_1 && simElapsedTime >= (spamStartTime_1 + spamDuration_1)) {
                    stopInterval(simIntervalID_spam_1); simIntervalID_spam_1 = null;
                    simSpamActive_1 = false;
                    document.getElementById("simSpamStatus_1").textContent = "Inactive";
                }
                
                if (spamTarget_2 !== "none" && simElapsedTime >= spamStartTime_2 && !simSpamActive_2) {
                    simSpamActive_2 = true;
                    startSimulatedCacheSpam(spamTarget_2, 2);
                    document.getElementById("simSpamStatus_2").textContent = `Spamming (${CACHE_COORDS[spamTarget_2]?.label || spamTarget_2})`;
                }
                if (simSpamActive_2 && simElapsedTime >= (spamStartTime_2 + spamDuration_2)) {
                    stopInterval(simIntervalID_spam_2); simIntervalID_spam_2 = null;
                    simSpamActive_2 = false;
                    document.getElementById("simSpamStatus_2").textContent = "Inactive";
                }

                reportLocationToSteering(simCurrentLat, simCurrentLon);
                if (simElapsedTime >= duration) {
                    stopCurrentSimulation(true);
                }
            }, 1000);
        }

        function startSimulatedMovement(targetCacheName, initialClientLat, initialClientLon, moveDurationSec, phaseId) {
            if (!CACHE_COORDS[targetCacheName]) {
                console.warn(`[MOVEMENT ${phaseId}] Target cache ${targetCacheName} not found.`);
                if (phaseId === 1) { simMovementActive_1 = false; document.getElementById("simMovementStatus_1").textContent = "Error"; }
                else { simMovementActive_2 = false; document.getElementById("simMovementStatus_2").textContent = "Error"; }
                return;
            }
            const targetCoord = CACHE_COORDS[targetCacheName];
            const totalSteps = moveDurationSec > 0 ? Math.max(1, Math.floor(moveDurationSec)) : 1;
            
            const stepLat = (targetCoord.lat - initialClientLat) / totalSteps;
            const stepLon = (targetCoord.lon - initialClientLon) / totalSteps;
            let stepsTaken = 0;

            let myIntervalSetter, myIntervalClearer, myActiveFlagGetter, myActiveFlagSetter, statusElementId;

            if (phaseId === 1) {
                if (simIntervalID_movement_1) clearInterval(simIntervalID_movement_1);
                simIntervalID_movement_1 = null;
                myIntervalSetter = (id) => simIntervalID_movement_1 = id;
                myIntervalClearer = () => { stopInterval(simIntervalID_movement_1); simIntervalID_movement_1 = null; };
                myActiveFlagGetter = () => simMovementActive_1; 
                myActiveFlagSetter = (val) => simMovementActive_1 = val;
                statusElementId = "simMovementStatus_1";
            } else { 
                if (simIntervalID_movement_2) clearInterval(simIntervalID_movement_2);
                simIntervalID_movement_2 = null;
                myIntervalSetter = (id) => simIntervalID_movement_2 = id;
                myIntervalClearer = () => { stopInterval(simIntervalID_movement_2); simIntervalID_movement_2 = null; };
                myActiveFlagGetter = () => simMovementActive_2;
                myActiveFlagSetter = (val) => simMovementActive_2 = val;
                statusElementId = "simMovementStatus_2";
            }

            const intervalFunc = () => {
                let currentIntervalId = (phaseId === 1) ? simIntervalID_movement_1 : simIntervalID_movement_2;
                if (!isSimulationRunning || !myActiveFlagGetter() || !currentIntervalId ) {
                    
                    
                    myIntervalClearer(); 
                    return;
                }

                if (stepsTaken < totalSteps) {
                    simCurrentLat += stepLat;
                    simCurrentLon += stepLon;
                    stepsTaken++;

                    document.getElementById("current-latitude").value = simCurrentLat.toFixed(5);
                    document.getElementById("current-longitude").value = simCurrentLon.toFixed(5);
                } else { 
                    simCurrentLat = targetCoord.lat;
                    simCurrentLon = targetCoord.lon;
                    document.getElementById("current-latitude").value = simCurrentLat.toFixed(5);
                    document.getElementById("current-longitude").value = simCurrentLon.toFixed(5);

                    myIntervalClearer();
                    myActiveFlagSetter(false); 
                    if(isSimulationRunning) document.getElementById(statusElementId).textContent = "Reached Target";
                }
            };
            myIntervalSetter(setInterval(intervalFunc, 1000));
        }

        function startSimulatedCacheSpam(targetCacheName, phaseId) {
            if (!CACHE_COORDS[targetCacheName]) {
                console.warn(`[SPAM ${phaseId}] Target cache ${targetCacheName} not found.`);
                if (phaseId === 1) { simSpamActive_1 = false; document.getElementById("simSpamStatus_1").textContent = "Error"; }
                else { simSpamActive_2 = false; document.getElementById("simSpamStatus_2").textContent = "Error"; }
                return;
            }
            let hostUrl = `https://${targetCacheName}/Eldorado/4sec/avc/7500000/seg-1.m4s?spam_ts=${Date.now()}&phase=${phaseId}`;

            let currentPhaseActiveFlag = (phaseId === 1) ? () => simSpamActive_1 : () => simSpamActive_2;
            let setSpamIntervalId = (val) => { if (phaseId === 1) simIntervalID_spam_1 = val; else simIntervalID_spam_2 = val; };
            let currentSpamIntervalId = (phaseId === 1) ? simIntervalID_spam_1 : simIntervalID_spam_2;
            let myIntervalClearer;
            if (phaseId === 1) myIntervalClearer = () => { stopInterval(simIntervalID_spam_1); simIntervalID_spam_1 = null; };
            else myIntervalClearer = () => { stopInterval(simIntervalID_spam_2); simIntervalID_spam_2 = null; };

            function sendSpamRequest() {
                if(isSimulationRunning && currentPhaseActiveFlag()) {
                     fetch(hostUrl).catch(err => {});
                } else {
                    myIntervalClearer();
                }
            }

            if (currentSpamIntervalId) clearInterval(currentSpamIntervalId);
            setSpamIntervalId(setInterval(sendSpamRequest, 100));
         }

        function reportLocationToSteering(lat, lon) {
            if (!isSimulationRunning || lat === undefined || lon === undefined) return;
            const payload = { time: simElapsedTime, lat: lat, long: lon };
            fetch("https://steering-service:30500/coords", {
                method: "POST", body: JSON.stringify(payload),
                headers: { "Content-type": "application/json; charset=UTF-8" }
            }).catch(error => console.warn("[CLIENT] Fetch (location) to /coords failed:", error));
        }

        function reportLatencyToSteering(lat, lon, latency, serverUsed) {
            if (!isSimulationRunning || lat === undefined || lon === undefined) return;
            if (latency === undefined || serverUsed === undefined) {
                 return;
            }
            const payload = { time: simElapsedTime, lat: lat, long: lon, rt: latency, server_used: serverUsed };
            fetch("https://steering-service:30500/coords", {
                method: "POST", body: JSON.stringify(payload),
                headers: { "Content-type": "application/json; charset=UTF-8" }
            })
            .then(response => response.text().then(text => ({ok: response.ok, status: response.status, text})))
            .then(data => {
                if (!data.ok) console.warn(`[CLIENT] Latency report /coords error ${data.status}: ${data.text}`);
            })
            .catch(error => console.error("[CLIENT] Fetch (latency) to /coords failed:", error));
        }

        function _load() {
            let newMpdUrl = document.getElementById("manifest").value;
            if (!newMpdUrl) { alert("Please enter an MPD URL."); return; }

            manifestSuccessfullyLoaded = false;
            document.getElementById("button_StartControlledSim").disabled = true;
            if (isSimulationRunning) stopCurrentSimulation(true);

            setupPlayer();
            _resetUIOnly();

            try {
                player.attachSource(newMpdUrl);

                if (onManifestLoadedCallback && player) player.off(dashjs.MediaPlayer.events.MANIFEST_LOADED, onManifestLoadedCallback);
                if (onManifestErrorCallback && player) player.off(dashjs.MediaPlayer.events.ERROR, onManifestErrorCallback);
                if (onStreamInitForAutomaticPlay && player) player.off(dashjs.MediaPlayer.events.STREAM_INITIALIZED, onStreamInitForAutomaticPlay);

                onManifestLoadedCallback = function(e) {
                    if(e.error) {
                        console.error("[CLIENT_LOAD] Error during MANIFEST_LOADED event:", e.error.message || e.error);
                        manifestSuccessfullyLoaded = false;
                        document.getElementById("button_StartControlledSim").disabled = true;
                    } else {
                        manifestSuccessfullyLoaded = true;
                        console.log("[CLIENT_LOAD] Manifest loaded successfully.");
                        const autoStartEnabled = document.getElementById("autoStartCheckbox").checked;

                        if (autoStartEnabled) {
                            console.log("[CLIENT_LOAD] Auto-start enabled. Attempting to start simulation.");
                            onStreamInitForAutomaticPlay = function() {
                                if (player.getActiveStream()) {
                                    if (manifestSuccessfullyLoaded && !isSimulationRunning) {
                                        startControlledSimulation();
                                    }
                                } else {
                                     console.warn("[CLIENT_LOAD_AUTO] STREAM_INITIALIZED event fired, but no active stream. Not auto-starting.");
                                }
                                if (player) player.off(dashjs.MediaPlayer.events.STREAM_INITIALIZED, onStreamInitForAutomaticPlay);
                            };
                            if (player.getActiveStream() && player.isReady()) {
                                onStreamInitForAutomaticPlay();
                            } else if (player.isReady()){
                                player.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, onStreamInitForAutomaticPlay, null, { once: true });
                            } else {
                                console.warn("[CLIENT_LOAD_AUTO] Player not ready after manifest load. Auto-start may fail or be delayed.");
                                document.getElementById("button_StartControlledSim").disabled = false;
                            }
                        } else {
                            document.getElementById("button_StartControlledSim").disabled = false;
                        }
                    }
                };
                player.on(dashjs.MediaPlayer.events.MANIFEST_LOADED, onManifestLoadedCallback, null, {once: true});

                onManifestErrorCallback = function(e) {
                    if (e.error && (e.error.code === dashjs.MediaPlayer.errors.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE ||
                                    e.error.code === dashjs.MediaPlayer.events.MANIFEST_LOADER_LOADING_FAILURE_ERROR_CODE ||
                                    e.error.code === dashjs.MediaPlayer.events.DOWNLOAD_ERROR_ID_MANIFEST)) {
                        console.error("[CLIENT_LOAD] FAILED to load/parse MPD (ERROR event):", e.error.message || e.error);
                        manifestSuccessfullyLoaded = false;
                        document.getElementById("button_StartControlledSim").disabled = true;
                    }
                };
                player.on(dashjs.MediaPlayer.events.ERROR, onManifestErrorCallback, null, {once: true});

            } catch (error) {
                 console.error("[CLIENT_LOAD] Critical error during player.attachSource():", error);
                 manifestSuccessfullyLoaded = false;
                 document.getElementById("button_StartControlledSim").disabled = true;
            }
        }

        function _onFragmentLoadingStarted(e) {
            try {
                if (e && e.mediaType && (e.mediaType === "video" || e.mediaType === "audio") && e.request) {
                    const key = e.mediaType + "_" + e.request.index;
                    if (e.request.serviceLocation) {
                        fragmentLoadStarts[key] = {
                            startTime: performance.now(),
                            serviceLocation: e.request.serviceLocation,
                            url: e.request.url
                        };
                        currentSegmentServiceLocation[e.mediaType] = e.request.serviceLocation;
                        _updateActiveServerIcons();
                    }
                }
            } catch (err) { console.error("[CLIENT] Error in _onFragmentLoadingStarted:", err); }
        }

        function _onFragmentLoadingCompleted(e) {
            try {
                const key = e.mediaType + "_" + e.request.index;
                if (e && e.request && fragmentLoadStarts[key]) {
                    const loadInfo = fragmentLoadStarts[key];
                    const endTime = performance.now();
                    let measuredLatencyMs = Math.round(endTime - loadInfo.startTime);
                    const serverUsed = loadInfo.serviceLocation;

                    delete fragmentLoadStarts[key];

                    let finalLatencyToReport = measuredLatencyMs;

                    if (isSimulationRunning && CACHE_COORDS[serverUsed] &&
                        simCurrentLat !== undefined && simCurrentLon !== undefined) {

                        const serverCoords = CACHE_COORDS[serverUsed];
                        const distanceKm = getDistanceFromLatLonInKm(
                            simCurrentLat, simCurrentLon,
                            serverCoords.lat, serverCoords.lon
                        );
                        const distanceLatencyPenalty = Math.round(distanceKm * LATENCY_MS_PER_KM);
                        finalLatencyToReport = measuredLatencyMs + distanceLatencyPenalty;
                        
                    }

                    if (isSimulationRunning) {
                        if (simCurrentLat !== undefined && simCurrentLon !== undefined) {
                            reportLatencyToSteering(simCurrentLat, simCurrentLon, finalLatencyToReport, serverUsed);
                        }
                    }
                }
            } catch (err) { console.error("[CLIENT] Error in _onFragmentLoadingCompleted:", err); }
        }

        function _onContentSteeringRequestCompleted(e) {
            try {
                if (!e) return;
                document.getElementById(`steering-request-timestamp`).innerText = new Date().toLocaleTimeString();
                if (e.url) document.getElementById(`steering-request-url`).innerText = decodeURIComponent(e.url);
                if (e.currentSteeringResponseData) {
                    const data = e.currentSteeringResponseData;
                    const priority = data["PATHWAY-PRIORITY"] || data.pathwayPriority || [];
                    document.getElementById(`steering-decision-display`).textContent = priority.map(p => CACHE_COORDS[p]?.label || p).join(' > ');
                    document.getElementById(`steering-pathway-cloning`).innerText = JSON.stringify(data["PATHWAY-CLONES"] || data.pathwayClones || [], null, 2);
                }
            } catch (err) { console.error("[CLIENT] Error in _onContentSteeringRequestCompleted:", err); }
        }
        function _createIcon(container, serviceLoc, domMap, prefix) {
            const span = document.createElement("span");
            span.id = `${prefix}-icon-${serviceLoc}`;
            const figure = document.createElement("figure"); figure.className = "cdn-selection";
            const img = document.createElement("img");
            img.src = "img/server.svg"; img.alt = serviceLoc;
            img.className = "figure-img img-fluid cdn-selection";
            const figCaption = document.createElement("figcaption"); figCaption.className = "figure-caption";
            figCaption.textContent = CACHE_COORDS[serviceLoc]?.label || serviceLoc;
            figure.append(img, figCaption); span.appendChild(figure); container.appendChild(span);
            domMap[serviceLoc] = img;
        }
        function _updateActiveServerIcons() {
            const activeServers = {};
            if (currentSegmentServiceLocation.audio) activeServers[currentSegmentServiceLocation.audio] = true;
            if (currentSegmentServiceLocation.video) activeServers[currentSegmentServiceLocation.video] = true;
            for (const serverName in cdnIconDomElements) {
                if (cdnIconDomElements.hasOwnProperty(serverName)) {
                    cdnIconDomElements[serverName].src = activeServers[serverName] ? "img/server-active.svg" : "img/server.svg";
                }
            }
        }
        document.addEventListener("DOMContentLoaded", init);
    </script>
</body>
</html>